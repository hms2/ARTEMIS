#' Generate cohorts to run ARTEMIS
#' @param connectionDetails A set of DatabaseConnector connectiondetails
#' @param json A loaded cohort from loadJSON()
#' @param name A cohort-specific name for written tables
#' @param cdmSchema A schema containing a valid OMOP CDM
#' @param writeSchema A schema where the user has write access
#' @export
generateCohorts <- function(connectionDetails, json, name, cdmSchema, writeSchema, cohortDefinitionId, exposureStart = 0, exposureEnd = NULL){

  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)

  cohortsToCreate <- CohortGenerator::createEmptyCohortDefinitionSet()
  cohortExpression <- CirceR::cohortExpressionFromJson(json$json[[1]])
  cohortSql <- CirceR::buildCohortQuery(cohortExpression, options = CirceR::createGenerateOptions(generateStats = FALSE))
  cohortsToCreate <- rbind(cohortsToCreate, data.frame(cohortId = 1,
                                                       cohortName = name,
                                                       sql = cohortSql,
                                                       stringsAsFactors = FALSE))

  cohortTableNames <- CohortGenerator::getCohortTableNames(cohortTable = name)

  CohortGenerator::createCohortTables(connection = connection,
                                      cohortDatabaseSchema = writeSchema,
                                      cohortTableNames = cohortTableNames)

  cohortsGenerated <- CohortGenerator::generateCohortSet(connection = connection,
                                                         cdmDatabaseSchema = cdmSchema,
                                                         cohortDatabaseSchema = writeSchema,
                                                         cohortTableNames = cohortTableNames,
                                                         cohortDefinitionSet = cohortsToCreate)

}

#' Generate a con_df dataframe without using CDMConnector
#' @param connectionDetails A set of DatabaseConnector connectiondetails
#' @param cohortTable The table where the cohort to run ARTHEMIS is stored
#' @param cohortDefinitionId The cohort to run ARTHEMIS on
#' @param cdmSchema A schema containing a valid OMOP CDM
#' @param writeSchema A schema where the user has write access
#' @param exposureStart The start day after which to consider drug exposures, with respect to cohort start date, using NULL to take the full history)
#' @param exposureEnd The end day before which to consider drug exposures, with respect to cohort end date, using NULL to take the full history)
#' @return A con_df dataframe
#' @export
getConDF <- function(connectionDetails, cohortTable, cdmSchema, writeSchema, cohortDefinitionId, exposureStart = 0, exposureEnd = NULL){

  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)

  sql_template <- "
WITH filtered_drug_exposure AS (
  SELECT @name.cohort_definition_id,
         @name.cohort_start_date,
         @name.cohort_end_date,
         drug_exposure.drug_exposure_id,
         drug_exposure.person_id,
         drug_exposure.drug_exposure_start_date,
         drug_exposure.drug_concept_id,
         concept_ancestor.ancestor_concept_id,
         concept.concept_name
  FROM @cdmSchema.drug_exposure
  LEFT JOIN @cdmSchema.concept_ancestor ON drug_exposure.drug_concept_id = concept_ancestor.descendant_concept_id
  LEFT JOIN @cdmSchema.concept ON concept_ancestor.ancestor_concept_id = concept.concept_id
  INNER JOIN @writeSchema.@name 
    ON drug_exposure.person_id = @name.subject_id
    {@cohortDefinitionId != ''} ? { AND @name.cohort_definition_id = @cohortDefinitionId }
    {@exposureStart != ''} ? { AND drug_exposure.drug_exposure_start_date >= DATEADD(day, @exposureStart, @name.cohort_start_date)}
    {@exposureEnd != ''} ? { AND drug_exposure.drug_exposure_start_date >= DATEADD(day, @exposureEnd, @name.cohort_end_date)}
  WHERE LOWER(concept.concept_class_id) = 'ingredient'
)
SELECT * FROM filtered_drug_exposure;
"

rendered_sql <- SqlRender::render(sql_template, cdmSchema = cdmSchema, writeSchema = writeSchema, name = cohortTable, exposureStart = exposureStart, exposureEnd = exposureEnd, cohortDefinitionId = cohortDefinitionId)

con_df <- DatabaseConnector::dbGetQuery(conn = connection,
                                        statement = rendered_sql)

con_df <- as.data.frame(con_df)

DatabaseConnector::disconnect(connection)

return(con_df)

}

#' Generate a set of patient drug record strings from a valid CDM connection and
#' a valid cohort JSON.
#' @param con_df A con_df dataframe returned by getCohortSet()
#' @param writeOut A variable indicating whether to save the set of drug records
#' @param outputName The name for a given written output
#' as a local file
#' @param validDrugs A dataframe containing a set of validDrugs
#' @return A dataframe containing the relevant patients and their drug exposure strings
#' @export
stringDF_from_cdm <- function(con_df, writeOut=TRUE, outputName = "Output", validDrugs) {

  cli::cat_bullet("Filtering dataframe to valid drugs only...",
                  bullet_col = "yellow", bullet = "info")

  con_df <- con_df[con_df$ancestor_concept_id %in% validDrugs$valid_concept_id,]

  cli::cat_bullet("Generating lag times and constructing drug record strings...",
                  bullet_col = "yellow", bullet = "info")

  #Correct lagtimes using dayTaken and start date for each subject ID
  con_df_out <- con_df %>%
    dplyr::mutate(
      reference_date = min(drug_exposure_start_date),
      dayTaken = as.numeric(drug_exposure_start_date - min(drug_exposure_start_date)), 
      .by = c(cohort_definition_id, cohort_start_date, cohort_end_date, person_id)
      ) %>%
    dplyr::arrange(cohort_definition_id, cohort_start_date, cohort_end_date, reference_date, person_id, dayTaken, concept_name) %>%
    dplyr::mutate(dayTaken2 = dayTaken - dplyr::lag(dayTaken, default = dplyr::first(dayTaken)), .by = c(cohort_definition_id, cohort_start_date, cohort_end_date, reference_date, person_id)) %>%
    dplyr::filter(!duplicated(paste(cohort_definition_id, cohort_start_date, cohort_end_date, reference_date, person_id, drug_exposure_start_date, concept_name)))

  con_df_out2 <- con_df_out  %>%
    dplyr::summarise(seq = paste(dayTaken2, ".", concept_name, ";", collapse = "", sep = ""), .by = c(cohort_definition_id, cohort_start_date, cohort_end_date, reference_date, person_id))

  con_df_out2$seq <- gsub(" ","",gsub(",","_",con_df_out2$seq))

  if(writeOut == TRUE){
    outputFile <- here::here()
    write.csv(file = paste(outputFile,"/",outputName,".csv",sep=""), x = con_df_out2, append = FALSE)
  }

  cli::cat_bullet("Complete!",
                  bullet_col = "green", bullet = "tick")

  return(con_df_out2)

}

#' Filter a stringDF dataframe to contain only valid patients
#' @param min Number of valid drugs in a given subject's drug record required to pass
#' the filter
#' @param stringDF A stringDF dataframe
#' @return A filtered dataframe containing the relevant patients and their
#' drug exposure strings
#' @export
filter_stringDF <- function(stringDF,min) {

  stringDF <- stringDF %>%
    dplyr::mutate(Count = stringr::str_count(seq, ";") + 1)

  stringDF <- stringDF[stringDF$Count >= min,]

  return(stringDF)

}

#' Load the default valid drugs dataframe
#' @export
loadDrugs <- function() {
  #data("validdrugs", package = "ARTEMIS")
  return(ARTEMIS::validdrugs)
}

#' Load regimens for a given condition
#' @param condition A string indicating which regimen set to load
#' Presently, the only condition fully mapped are lungCancer and multiple myeloma
#' @export
loadRegimens <- function(condition) {
  if(condition == "lungCancer"){
    #data("regimens", package = "ARTEMIS")
    return(ARTEMIS::regimens %>% filter(metaCondition == "Thoraic Oncology"))
  } else if (condition == "multipleMyeloma"){
    return(ARTEMIS::regimens %>% filter(metaCondition == "Multiple Myeloma"))
  } else {
    message("Invalid condition. Please try running validConditions()")
  }
}

#' Display a list of valid conditions
#' @export
validConditions <- function(){
  message("Conditions currently implemented:")
  message("lungCancer")
  message("multipleMyeloma")
}

#' Load the default regimen group dataframe
#' @export
loadGroups <- function() {
  #data("regimengroups", package = "ARTEMIS")
  return(ARTEMIS::regimengroups)
}

#' Load the default regimen group dataframe
#' @export
loadCohort <- function() {
  #data("json", package = "ARTEMIS")
  return(ARTEMIS::json)
}

#' Filter a stringDF dataframe to contain only valid patients
#' @param output_all A dataframe containing raw outputs
#' @param processedAll A dataframe containing processed output regimens
#' @param processedEras A dataframe containing processed regimen eras
#' @param regGroups The desired regimen grouping variables for Sankey construction
#' @param regStats A dataframe containing various summary statistics
#' @param connectionDetails A set of DatabaseConnector connectiondetails
#' @param cdmSchema A schema containing a valid OMOP CDM
#' @param con_df The con dataframe object generated by getCohortSet
#' @param stringDF A stringDF object containing all valid patients (i.e., those who have exposure
#' to at least one valid drug)
#' @param skipSummaryStats A toggle indicating whether or not the user wishes to skip generating additional summary statistics
#' @export
writeOutputs <- function(output_all, processedAll, processedEras, regGroups, regStats, connectionDetails, cdmSchema, con_df, stringDF, skipSummaryStats = FALSE){
  uniqueIDs <- unique(output_all$personID)
  random_ids <- sample(1:10000000, length(uniqueIDs), replace = F) %>% as.character()
  id_dictionary <- cbind(uniqueIDs, random_ids) %>% `colnames<-`(c("personID", "anonymisedID")) %>% as.data.frame()

  output_all_anon <- merge(output_all,id_dictionary)[,-1]
  processedAll_anon <- merge(processedAll,id_dictionary)[,-1]
  output_eras_anon <- merge(processedEras,id_dictionary)[,-1]

  dir.create(file.path(here::here(), "output_data"), showWarnings = FALSE)
  dir.create(file.path(here::here(), "output_stats"), showWarnings = FALSE)
  dir.create(file.path(here::here(), "output_plots"), showWarnings = FALSE)

  cli::cat_bullet("Generating cohort level stats...",
                  bullet_col = "yellow", bullet = "info")

  if(!skipSummaryStats) {
    cohortStats <- generateCohortStats(connectionDetails = connectionDetails, cdmSchema = cdmSchema, con_df = con_df, stringDF = stringDF)
  } else {
    cohortStats <- data.frame(Characters=character(),
                              stringsAsFactors=FALSE)
  }

  cli::cat_bullet("Saving anonymised patient-level data...",
                  bullet_col = "yellow", bullet = "info")

  write.csv(x = output_all_anon, file = here::here("output_data/OutputAll.csv"))
  write.csv(x = processedAll_anon, file = here::here("output_data/OutputProcessed.csv"))
  write.csv(x = output_eras_anon, file = here::here("output_data/OutputEras.csv"))

  cli::cat_bullet("Saving aggregate data...",
                  bullet_col = "yellow", bullet = "info")

  write.csv(x = regStats, file = here::here("output_stats/regstats.csv"))
  write.csv(x = cohortStats, file = here::here("output_stats/CohortStats.csv"))

  cli::cat_bullet("Generating and saving sample plots (This may take a moment)...",
                  bullet_col = "yellow", bullet = "info")

  plotSankey(processedEras, regGroups, saveLocation = "output_plots/", fileName = "Sankey_Network")

  idTest <- unique(output_all_anon$anonymisedID)

  if(length(idTest) > 50){
    plotIDs <- sample(unique(output_all_anon$anonymisedID), size = 50, replace = F)
  } else {
    plotIDs <- idTest
  }

  for(i in c(1:length(plotIDs))){
    temp_output <- output_all_anon[output_all_anon$anonymisedID==plotIDs[i],]
    temp_plot <- plotOutput(temp_output, fontSize = 1.5, regimenCombine = 28) + ggplot2::ggtitle(paste("Test Plot: ",plotIDs[i],sep=""))
    filename <- paste("output_plots/Test_",plotIDs[i],".png",sep="")
    suppressWarnings(
      ggplot2::ggsave(filename, plot = temp_plot, device = "png", height = 7, width = 10)
    )
  }

  zip(zipfile = "output_data.zip", files = "output_data/")
  zip(zipfile = "output_stats.zip", files = "output_stats/")
  zip(zipfile = "output_plots.zip", files = "output_plots/")

  unlink('output_stats/', recursive=TRUE)
  unlink('output_data/', recursive=TRUE)
  unlink('output_plots/', recursive=TRUE)

  cli::cat_bullet("Complete!",
                  bullet_col = "green", bullet = "tick")

}
